{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "bdd88b54-eeee-424d-ba07-853aa1a3bfef",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np \n",
    "import sys \n",
    "import os "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "4e4d6acb-61ca-42ec-9f98-2b2a6b3641ab",
   "metadata": {},
   "outputs": [],
   "source": [
    "def padding(image, pad):\n",
    "    \"\"\"\n",
    "    Add zero-padding to each channel of a 3D umpy tensor.\n",
    "\n",
    "    Parameters:\n",
    "    ----------\n",
    "\n",
    "    image : numpy.ndarray\n",
    "\n",
    "        A 3D numpy array of shape (C, H, W), where:\n",
    "        - C is the number  of channels (3 for RGB iamges)\n",
    "        - H is the height of the image\n",
    "        - W is the width of the image\n",
    "\n",
    "    pad : int\n",
    "        The amount of zero-padding to add around the borders on each channels.\n",
    "        Padding ill be added symmetrically so that there is equal padding on all sides.\n",
    "\n",
    "    Returns:\n",
    "    --------\n",
    "\n",
    "    numpy.ndarray\n",
    "        A 3D array with shape (C, H + 2* pad , W + 2 * pad)\n",
    "\n",
    "    \"\"\"\n",
    "\n",
    "    # There are three channels; each channel will have paddings added\n",
    "    C, H, W = image.shape\n",
    "    output_shape = (C, H + 2 * pad, W + 2 * pad)\n",
    "    output = np.zeros(output_shape)\n",
    "\n",
    "    for channel_index in range(C):\n",
    "        output[channel_index] = np.pad(image[channel_index],\n",
    "                                       pad_width=((pad, pad), (pad, pad)),\n",
    "                                       mode='constant', \n",
    "                                       constant_values=0)\n",
    "    return output\n",
    "\n",
    "\n",
    "def MaxPool( conv_image , kernel_size , stride=1): \n",
    "        \"\"\"\n",
    "        Subsampling layer. \n",
    "\n",
    "        Parameters:\n",
    "        -----------\n",
    "            - conv_image : image in numpy and dimension (C, H, W) \n",
    "            - kernel_size : kernel_size of the pooling layer. The kernel stays rectangular  \n",
    "            - stride : stide of the pooling layer \n",
    "\n",
    "        Returns:\n",
    "        --------\n",
    "        pooled in numpy \n",
    "        \n",
    "        \"\"\"\n",
    "        # Get input dimensions \n",
    "        input_channel ,input_height , input_width = conv_image.shape\n",
    "    \n",
    "        # Get the output dimensions \n",
    "        output_height = (input_height - kernel_size) // stride+1 \n",
    "        output_width = (input_width - kernel_size) // stride+1 \n",
    "\n",
    "        \"\"\"\n",
    "        print(\"input height : \" , input_height ) \n",
    "        print(\"input width : \" , input_width ) \n",
    "        print(\"output_height : \", output_height )\n",
    "        print(\"output_width : \", output_width ) \n",
    "        \"\"\"\n",
    "        \n",
    "    \n",
    "        # initialize a np 3D array for pooling kernel \n",
    "        pooled_ = np.zeros((input_channel, output_height, output_width )) \n",
    "        #print(pooled_.shape) \n",
    "\n",
    "        #sys.exit(-1) \n",
    "            \n",
    "        # 2. Scan through the input image and get the max \n",
    "\n",
    "        # The iteration below will be honsistent for 3 dimensions; as of now it is for 2 . \n",
    "        # Apply pooling operation per channel\n",
    "    \n",
    "        for c in range(input_channel): # iterate across the channel \n",
    "            \n",
    "            for j in range(0, input_height - kernel_size + 1, stride): # iterate across the height\n",
    "                \n",
    "                for i in range(0, input_width - kernel_size + 1, stride): # iterate across the width \n",
    "                    \n",
    "                    # Define the current window\n",
    "                    \n",
    "                    window = conv_image[c, j:j + kernel_size, i:i + kernel_size]\n",
    "        \n",
    "                    # Get the max value in the window\n",
    "                    max_value = np.max(window)\n",
    "        \n",
    "                    # Map max value to the output matrix\n",
    "                    pooled_[c, j // stride, i // stride] = max_value # fixed to get integer size\n",
    "        \n",
    "        return pooled_\n",
    "\n",
    "# Get the backprop wrt to the input \n",
    "def backward_wrt_input(input_image, kernel ,stride=1):     \n",
    "    \n",
    "    \"\"\"\n",
    "     Description: \n",
    "    -----------\n",
    "    The image input is an input of dimension (1, H, W). \n",
    "    KEY INSIGHT : The CNN Backpropagation operation with stride>1 is identical to a stride = 1. \n",
    "    \n",
    "\n",
    "    Parameters: \n",
    "    -----------\n",
    "        \n",
    "\n",
    "\n",
    "    Returns: \n",
    "    --------\n",
    "    updated weights \n",
    "\n",
    "    ----\n",
    "    \n",
    "    Note: \n",
    "        i)  See if stride is a factor here. \n",
    "        ii) \n",
    "        iii) \n",
    "        \n",
    "        key formula : dL_dx = full_convolution(kernel, loss gradient dL_dz ) \n",
    "        dL_dO is dL_dz in MMP's code\n",
    "\n",
    "        z/O is the output of the convolution layer \n",
    "        dL_do/dL_dz \n",
    "    \n",
    "    ----\n",
    "    \"\"\"    \n",
    "    \n",
    "    print(input_image.shape)   \n",
    "    # Since this is a single layer, let us ignore the dimension C.\n",
    "    \n",
    "    # Step 1. filp the filter/kernel 180 degree; assume that a single kernel is 3D i.e. (1, H, W) \n",
    "    kernel_rotated = kernel[: , ::-1, ::-1 ] # replace this with\n",
    "    \n",
    "    # Step 2. pad the dL_dz\n",
    "    dL_dz_padded_1 = padding(dL_dz_test, 1) # padding dL_dZ with 1) \n",
    "\n",
    "    \"\"\"\n",
    "    \n",
    "    dL_dz_test_padded_1 shape : (1, 30, 30) \n",
    "    kernel_rotated : (1, 5, 5) \n",
    "    \n",
    "    \n",
    "    convolutional arithmetic : ( ((30-5) + 2* padding) / stride) ) + 1  \n",
    "    \n",
    "    \n",
    "    \"\"\"\n",
    "\n",
    "    image_height = dL_dz_padded_1.shape[-1]\n",
    "    kernel_height = kernel_rotated.shape[-1]\n",
    "    stride_ = 1  \n",
    "\n",
    "    output_dimension = image_height - kernel_height // 1\n",
    "\n",
    "    print(\"output dimension : \", output_dimension)\n",
    "\n",
    "    print(\"---------\") \n",
    "    \n",
    "    print(\"dL_dz before padding : \" , dL_dz_test.shape ) \n",
    "    print(\"dL_dz_padded_1 , after initialization : \", dL_dz_padded_1.shape ) \n",
    "\n",
    "    print(\"Update : Padding applied successfully\" ) \n",
    "    output = np.zeros( (output_dimension, output_dimension) ) \n",
    "\n",
    "    print(\"output shape \", output.shape) \n",
    "    #sys.exit(-2) \n",
    "    \n",
    "    # Step 3: \n",
    "    # perform convolution between dL_dz_padded_1 and kernel_rotated- the results will be in output matrix \n",
    "\n",
    "    print(\"--------------\") \n",
    "    # Step 3: Perform the convolution operation --->> This should be a separate function., \n",
    "    \n",
    "    # add another loop to iterate across all the channels \n",
    "    # (Batch Size, Channel, Height, Width) --> in my code (Channel (C), Height (i), Width (j)) \n",
    "    \n",
    "    for i in range(0, output_dimension):\n",
    "        \n",
    "        for j in range(0, output_dimension):\n",
    "            \n",
    "            # Extract the patch of the same size as the kernel\n",
    "            patch = dL_dz_padded_1[0, i:i+kernel_height, j:j+kernel_height]\n",
    "\n",
    "            # Perform element-wise multiplication and sum\n",
    "            output[i, j] = np.sum(patch * kernel_rotated[0])\n",
    "\n",
    "            print(\"i, j: (\", i, j , \")\")\n",
    "\n",
    "    \n",
    "    #print(\"dL_dx: After convolution is applied\")\n",
    "    #print(output)\n",
    "    print(\"--------------\") \n",
    "\n",
    "\n",
    "    \"\"\"\n",
    "    output is dL/dX \n",
    "    \"\"\"    \n",
    "    \n",
    "    #for i in range(dl_dz_padded_1.shape[0]): #6, 32, 32 #x = 32, 32     \n",
    "    #    convolve(dl_dz_padded[i], kernel)\n",
    "                \n",
    "                        \n",
    "        #    output[] = convolute(patch, kernel)\n",
    "\n",
    "    #print(\"dL_dx : after convolution is applied\", ) \n",
    "\n",
    "    print(\"output \" , output.shape) \n",
    "\n",
    "    # update the weight \n",
    "         \n",
    "\n",
    "#backward_wrt_input(input_image, kernel, stride=1)    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "e67e49b2-7a01-4df9-958e-015ff2d1fb38",
   "metadata": {},
   "outputs": [],
   "source": [
    "# define the path for the data \n",
    "batch_images_path = os.path.join(\"data\", \"single batch\", \"batch_images.npy\") \n",
    "batch_labels_path = os.path.join(\"data\", \"single batch\" , \"batch_labels.npy\") \n",
    "\n",
    "# load the adata \n",
    "batch_images = np.load(batch_images_path)\n",
    "batch_labels = np.load(batch_labels_path) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "cee829bc-259f-4f17-ac46-98fc873796b9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "batch images shape :  (32, 3, 32, 32)\n",
      "batch labels shape :  (32,)\n"
     ]
    }
   ],
   "source": [
    "#check the shape of batch images \n",
    "print(\"batch images shape : \", batch_images.shape)\n",
    "\n",
    "# check the shape of batch labels \n",
    "print(\"batch labels shape : \", batch_labels.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fd45b480-56ff-48c5-b9f4-64975603b3ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "# First see if the functions work for one iamge \n",
    "image = batch_images[5] \n",
    "label = batch_labels[5] \n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
